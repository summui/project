<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ForecastFutureBuy - Sales Prediction</title>

  <!-- Chart.js core -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
  <!-- Zoom/pan plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.2.0/dist/chartjs-plugin-zoom.min.js"></script>
  <!-- Matrix (heatmap) plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@2.0.1/dist/chartjs-chart-matrix.min.js"></script>

  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif; background:#f6f7fb; margin:0; padding:16px; color:#111827; }
    .container { max-width:1200px; margin:0 auto; }
    .card { background:#fff; border:1px solid #e5e7eb; border-radius:12px; padding:16px; margin-bottom:16px; box-shadow:0 6px 18px rgba(0,0,0,0.05); }
    .header { text-align:center; padding:16px; background:linear-gradient(135deg,#ede9fe,#ddd6fe); border:1px solid #e5e7eb; border-radius:12px; margin-bottom:16px; }
    h1 { margin:0 0 8px; color:#4c1d95; }
    .date-info { text-align:center; color:#6b7280; font-size:0.95rem; margin-bottom:16px; }
    .grid { display:grid; gap:16px; }
    .form-grid { grid-template-columns: repeat(5, 1fr); }
    @media (max-width: 980px){ .form-grid{ grid-template-columns: repeat(2,1fr);} }
    @media (max-width: 520px){ .form-grid{ grid-template-columns: 1fr;} }
    .input-group{ display:flex; flex-direction:column; gap:6px; }
    label{ font-size:0.85rem; font-weight:600; color:#374151; }
    select, input[type="month"]{ padding:10px 12px; border:1px solid #d1d5db; border-radius:10px; outline:none; font-size:0.95rem; background:#fff; }
    select:disabled{ background:#f3f4f6; color:#9ca3af; }
    button{ padding:12px 16px; border:none; border-radius:10px; background:#7c3aed; color:#fff; font-weight:700; cursor:pointer; }
    button:disabled{ background:#a78bfa; cursor:not-allowed; }
    .messages{ margin:8px 0; }
    .msg{ display:none; padding:10px 12px; border-radius:10px; text-align:center; }
    .error{ background:#fee2e2; color:#b91c1c; border:1px solid #fecaca; }
    .success{ background:#dcfce7; color:#166534; border:1px solid #bbf7d0; }
    .charts-2 { grid-template-columns: 1fr 1fr; }
    @media (max-width: 980px){ .charts-2{ grid-template-columns: 1fr; } }
    .chart-box{ height:380px; }
    @media (min-width: 1024px){ .chart-box{ height:420px; } }
    .subtle{ color:#6b7280; font-size:0.9rem; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header card">
      <h1>ForecastFutureBuy</h1>
      <div class="subtle">Product Sales Prediction</div>
    </div>

    {% if min_date and max_date %}
    <div class="date-info card">Available Data Range: {{ min_date }} to {{ max_date }}</div>
    {% endif %}

    <div class="card">
      <div class="grid form-grid">
        <div class="input-group">
          <label for="brand">Brand</label>
          <select id="brand" required>
            <option value="">Select Brand</option>
            {% for b in brands %}
              <option value="{{ b }}">{{ b }}</option>
            {% endfor %}
          </select>
        </div>
        <div class="input-group">
          <label for="product">Product</label>
          <select id="product" required disabled>
            <option value="">Select a brand first</option>
          </select>
        </div>
        <div class="input-group">
          <label for="model">Model</label>
          <select id="model" required disabled>
            <option value="">Select a product first</option>
          </select>
        </div>
        <div class="input-group">
          <label for="start-date">Start</label>
          <input type="month" id="start-date" required {% if min_date and max_date %} min="{{ min_date }}" max="{{ max_date }}" {% endif %} />
        </div>
        <div class="input-group">
          <label for="end-date">End</label>
          <input type="month" id="end-date" required {% if min_date and max_date %} min="{{ min_date }}" max="{{ max_date }}" {% endif %} />
        </div>
      </div>
      <div style="margin-top:10px;">
        <button id="predict-btn">Predict</button>
      </div>
      <div class="messages">
        <div id="err" class="msg error"></div>
        <div id="ok" class="msg success"></div>
      </div>
    </div>

    <div id="results" class="card" style="display:none;">
      <div style="font-weight:700;margin-bottom:8px;">Overview</div>
      <div id="rec-text" class="subtle">—</div>

      <div class="grid charts-2" style="margin-top:12px;">
        <div class="card">
          <div style="font-weight:700; margin-bottom:6px;">Historical Sales (Adaptive View)</div>
          <div class="chart-box"><canvas id="historicalChart"></canvas></div>
        </div>
        <div class="card">
          <div style="font-weight:700; margin-bottom:6px;">Forecast (with Confidence Band)</div>
          <div class="chart-box"><canvas id="forecastChart"></canvas></div>
        </div>
      </div>

      <div class="grid charts-2" style="margin-top:12px;">
        <div class="card">
          <div style="font-weight:700; margin-bottom:6px;">Seasonality Heatmap (GitHub Style)</div>
          <div class="chart-box"><canvas id="seasonalityChart"></canvas></div>
        </div>
        <div class="card">
          <div style="font-weight:700; margin-bottom:6px;">Revenue (Historical + Forecast)</div>
          <div class="chart-box"><canvas id="revenueChart"></canvas></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Chart defaults
    Chart.defaults.font.family = "system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif";
    Chart.defaults.plugins.legend.labels.usePointStyle = true;

    // Elements
    const brandEl = document.getElementById('brand');
    const productEl = document.getElementById('product');
    const modelEl = document.getElementById('model');
    const startEl = document.getElementById('start-date');
    const endEl = document.getElementById('end-date');
    const predictBtn = document.getElementById('predict-btn');
    const errEl = document.getElementById('err');
    const okEl = document.getElementById('ok');
    const resultsEl = document.getElementById('results');
    const recEl = document.getElementById('rec-text');

    const MIN_DATE = '{{ min_date }}';
    const MAX_DATE = '{{ max_date }}';

    // Charts
    let histChart=null, fcChart=null, seasChart=null, revChart=null;

    // Defaults for dates
    (function setDefaults(){
      if (MIN_DATE && MAX_DATE) {
        const maxDate = new Date(MAX_DATE + '-01');
        const minDate = new Date(MIN_DATE + '-01');
        const defaultStart = new Date(maxDate);
        defaultStart.setMonth(defaultStart.getMonth() - 6);
        startEl.value = (defaultStart < minDate) ? MIN_DATE : defaultStart.toISOString().slice(0,7);
        endEl.value = MAX_DATE;
      }
    })();

    // Helpers
    function showError(msg){ errEl.textContent=msg; errEl.style.display='block'; okEl.style.display='none'; }
    function showOk(msg){ okEl.textContent=msg; okEl.style.display='block'; errEl.style.display='none'; }
    function clearMsgs(){ errEl.style.display='none'; okEl.style.display='none'; }
    function validateDates(){
      const s=startEl.value, e=endEl.value;
      if (!s || !e) return false;
      if (s >= e){ showError('End date must be after start date.'); return false; }
      if (MIN_DATE && s < MIN_DATE){ showError(`Start date must be ≥ ${MIN_DATE}.`); return false; }
      if (MAX_DATE && e > MAX_DATE){ showError(`End date must be ≤ ${MAX_DATE}.`); return false; }
      return true;
    }
    function populateSelect(sel, items, placeholder){
      sel.innerHTML='';
      if (items && items.length){
        sel.add(new Option(placeholder,''));
        items.forEach(v=>sel.add(new Option(v,v)));
        sel.disabled=false;
      } else {
        sel.add(new Option(`No ${placeholder.toLowerCase()} found`, ''));
        sel.disabled=true;
      }
    }

    // Downsample labels and data to every Nth point
    function downsampleSeries(labels, values, step) {
      if (step <= 1) return { labels, values };
      const dsL = [], dsV = [];
      for (let i = 0; i < labels.length; i += step) {
        dsL.push(labels[i]);
        dsV.push(values[i]);
      }
      return { labels: dsL, values: dsV };
    }
    // Aggregate monthly values to quarterly
    function toQuarterly(labels, values) {
      const outL = [], outV = [];
      let qSum = 0, currentQ = null;
      for (let i = 0; i < labels.length; i++) {
        const [y, m] = labels[i].split('-').map(Number);
        const q = Math.floor((m - 1) / 3) + 1;
        const tag = `${y}-Q${q}`;
        if (currentQ === null) currentQ = tag;
        if (tag !== currentQ) {
          outL.push(currentQ);
          outV.push(qSum);
          qSum = 0; currentQ = tag;
        }
        qSum += Number(values[i] || 0);
      }
      if (currentQ !== null) {
        outL.push(currentQ);
        outV.push(qSum);
      }
      return { labels: outL, values: outV };
    }
    // Decide presentation mode based on span
    function pickScaleMode(labels) {
      if (!labels.length) return { mode: 'monthly', step: 1 };
      const startY = Number(labels[0].slice(0,4));
      const endY = Number(labels[labels.length-1].slice(0,4));
      const span = endY - startY + 1;
      if (span >= 12) return { mode: 'quarterly' };        // 12+ years → quarterly bars
      if (span >= 6) return { mode: 'monthly', step: 3 };  // 6–11 years → every 3rd month
      if (span >= 3) return { mode: 'monthly', step: 2 };  // 3–5 years → every 2nd month
      return { mode: 'monthly', step: 1 };
    }
    // Heatmap color scale (purple ramp)
    function heatmapColor(value, vmax) {
      if (!vmax || vmax <= 0) return 'rgba(229,231,235,1)'; // light gray
      const t = Math.max(0, Math.min(1, value / vmax));
      // color stops: #ede9fe, #ddd6fe, #c4b5fd, #a78bfa, #7c3aed
      const stops = [
        [237,233,254],
        [221,214,254],
        [196,181,253],
        [167,139,250],
        [124, 58,237],
      ];
      const idx = Math.min(stops.length - 1, Math.floor(t * (stops.length - 1)));
      const [r,g,b] = stops[idx];
      return `rgba(${r},${g},${b},1)`;
    }

    // Cascading selects
    brandEl.addEventListener('change', async function(){
      clearMsgs();
      const b=this.value;
      productEl.disabled=true; modelEl.disabled=true;
      productEl.innerHTML='<option value="">Loading...</option>';
      modelEl.innerHTML='<option value="">Select a product first</option>';
      if (!b){ productEl.innerHTML='<option value="">Select a brand first</option>'; return; }
      try{
        const r=await fetch(`/api/products/${encodeURIComponent(b)}`);
        if(!r.ok) throw new Error('Failed to fetch products');
        const products=await r.json();
        populateSelect(productEl, products, 'Select Product');
        modelEl.innerHTML='<option value="">Select a product first</option>';
        modelEl.disabled=true;
      }catch(e){ showError(e.message); productEl.innerHTML='<option value="">Error loading products</option>'; productEl.disabled=true; }
    });

    productEl.addEventListener('change', async function(){
      clearMsgs();
      const b=brandEl.value, p=this.value;
      modelEl.disabled=true; modelEl.innerHTML='<option value="">Loading...</option>';
      if (!b || !p){ modelEl.innerHTML='<option value="">Select brand and product first</option>'; return; }
      try{
        const r=await fetch(`/api/models/${encodeURIComponent(b)}/${encodeURIComponent(p)}`);
        if(!r.ok) throw new Error('Failed to fetch models');
        const models=await r.json();
        populateSelect(modelEl, models, 'Select Model');
      }catch(e){ showError(e.message); modelEl.innerHTML='<option value="">Error loading models</option>'; modelEl.disabled=true; }
    });

    // Predict
    predictBtn.addEventListener('click', async function(){
      clearMsgs();
      const b=brandEl.value, p=productEl.value, m=modelEl.value, s=startEl.value, e=endEl.value;
      if(!b||!p||!m||!s||!e){ showError('Please select brand, product, model, and both dates.'); return; }
      if(!validateDates()) return;
      predictBtn.disabled=true;
      try{
        const resp=await fetch('/api/forecast', {
          method:'POST', headers:{'Content-Type':'application/json','Accept':'application/json'},
          body:JSON.stringify({brand:b,product:p,model:m,start_date:s+'-01',end_date:e+'-01'})
        });
        const data=await resp.json();
        if(!resp.ok) throw new Error(data.error||'Failed to get forecast');
        renderAll(data);
        resultsEl.style.display='block';
        showOk('Forecast generated successfully.');
      }catch(err){ showError(err.message); }
      finally{ predictBtn.disabled=false; }
    });

    function renderAll(data){
      recEl.textContent = data?.recommendation?.message || 'Forecast generated.';
      renderHistorical(data);
      renderForecast(data);
      renderSeasonality(data?.seasonality||[]);
      renderRevenue(data);
    }

    function renderHistorical(data){
      const ctx=document.getElementById('historicalChart').getContext('2d');
      if(histChart) histChart.destroy();
      const labels=data?.history?.labels||[];
      const values=data?.history?.values||[];

      const mode = pickScaleMode(labels);
      let L = labels, V = values, type='line', datasets;

      if (mode.mode === 'quarterly') {
        const q = toQuarterly(labels, values);
        L = q.labels; V = q.values; type='bar';
      } else if (mode.step > 1) {
        const ds = downsampleSeries(labels, values, mode.step);
        L = ds.labels; V = ds.values;
      }

      if (type==='line') {
        const ma = (arr, w) => arr.map((_,i)=> i+1<w ? null : Math.round(arr.slice(i-w+1,i+1).reduce((a,b)=>a+Number(b||0),0)/w));
        const ma3 = ma(V,3), ma6 = ma(V,6), ma12 = ma(V,12);
        datasets = [
          { label:'Historical', data:V, borderColor:'#7c3aed', backgroundColor:'rgba(124,58,237,0.12)', fill:true, tension:0.35 },
          { label:'MA(3)', data:ma3, borderColor:'#10b981', borderDash:[6,4], tension:0.35 },
          { label:'MA(6)', data:ma6, borderColor:'#f59e0b', borderDash:[6,4], tension:0.35 },
          { label:'MA(12)', data:ma12, borderColor:'#ef4444', borderDash:[6,4], tension:0.35 }
        ];
      } else {
        datasets = [
          { label:'Historical (Quarterly)', data:V, backgroundColor:'rgba(124,58,237,0.7)', borderColor:'#7c3aed' }
        ];
      }

      histChart = new Chart(ctx, {
        type,
        data: { labels:L, datasets },
        options:{
          responsive:true, maintainAspectRatio:false,
          interaction:{ intersect:false, mode:'index' },
          scales:{ y:{ beginAtZero:true }, x:{ ticks:{ maxRotation:45, autoSkip:true, maxTicksLimit:12 } } },
          plugins:{
            legend:{ labels:{ usePointStyle:true} },
            zoom:{
              pan:{ enabled:true, mode:'x' },
              zoom:{ wheel:{ enabled:true }, pinch:{ enabled:true }, mode:'x' }
            }
          }
        }
      });
    }

    function renderForecast(data){
      const ctx=document.getElementById('forecastChart').getContext('2d');
      if(fcChart) fcChart.destroy();
      const labels=data?.forecast?.labels||[];
      const vals=data?.forecast?.values||[];
      const highs=data?.forecast?.highs||[];
      const lows=data?.forecast?.lows||[];

      fcChart = new Chart(ctx, {
        type:'line',
        data:{
          labels,
          datasets:[
            { label:'Confidence Upper', data:highs, borderColor:'rgba(167,139,250,0.8)', backgroundColor:'rgba(167,139,250,0.15)', fill:'+1', pointRadius:0, tension:0.35 },
            { label:'Confidence Lower', data:lows,  borderColor:'rgba(167,139,250,0.8)', backgroundColor:'rgba(167,139,250,0.15)', fill:'-1', pointRadius:0, tension:0.35 },
            { label:'Forecast', data:vals, borderColor:'#2563eb', backgroundColor:'rgba(37,99,235,0.08)', fill:false, tension:0.35 }
          ]
        },
        options:{
          responsive:true, maintainAspectRatio:false,
          interaction:{ intersect:false, mode:'index' },
          scales:{ y:{ beginAtZero:true }, x:{ ticks:{ maxRotation:45, autoSkip:true } } },
          plugins:{
            legend:{ labels:{ usePointStyle:true } },
            zoom:{
              pan:{ enabled:true, mode:'x' },
              zoom:{ wheel:{ enabled:true }, pinch:{ enabled:true }, mode:'x' }
            }
          }
        }
      });
    }

    function renderSeasonality(heat){
      const ctx=document.getElementById('seasonalityChart').getContext('2d');
      if(seasChart) seasChart.destroy();

      if (!Array.isArray(heat) || !heat.length) {
        seasChart = new Chart(ctx, { type:'bar', data:{ labels:[], datasets:[] }, options:{ responsive:true, maintainAspectRatio:false }});
        return;
      }

      const years = [...new Set(heat.map(h=>h.year))].sort((a,b)=>a-b);
      let vmax = 0;
      heat.forEach(h => { if (h.value > vmax) vmax = h.value; });

      const yIndex = (y) => years.indexOf(y);
      const matrixData = heat.map(h => ({
        x: h.month - 1,
        y: yIndex(h.year),
        v: h.value,
        w: 18,
        h: 18
      }));

      seasChart = new Chart(ctx, {
        type: 'matrix',
        data: {
          datasets: [{
            label: 'Seasonality',
            data: matrixData,
            backgroundColor: ctx => heatmapColor(ctx.raw.v, vmax),
            borderColor: 'rgba(255,255,255,0.8)',
            borderWidth: 1,
            width: ctx => ctx.raw.w,
            height: ctx => ctx.raw.h
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                title: () => '',
                label: ctx => {
                  const mIdx = ctx.raw.x;
                  const year = years[ctx.raw.y];
                  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                  return `${monthNames[mIdx]} ${year}: ${ctx.raw.v.toLocaleString()}`;
                }
              }
            }
          },
          scales: {
            x: {
              type: 'linear',
              position: 'top',
              min: -0.5,
              max: 11.5,
              ticks: {
                callback: (v) => ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][v],
                maxRotation: 0,
                autoSkip: false
              },
              grid: { display: false }
            },
            y: {
              type: 'linear',
              min: -0.5,
              max: years.length - 0.5,
              ticks: { callback: (v) => years[v] ?? '', autoSkip: false },
              reverse: true,
              grid: { display: false }
            }
          }
        }
      });
    }

    function renderRevenue(data){
      const ctx=document.getElementById('revenueChart').getContext('2d');
      if(revChart) revChart.destroy();
      const histLabels=data?.history?.labels||[];
      const histRev=data?.history?.revenue||[];
      const fLabels=data?.forecast?.labels||[];
      const fRev=data?.forecast?.revenue||[];

      const mode = pickScaleMode(histLabels);
      let Lh=histLabels, Rh=histRev, type='bar';

      if (mode.mode === 'quarterly') {
        const q = toQuarterly(histLabels, histRev);
        Lh = q.labels; Rh = q.values;
      } else if (mode.step > 1) {
        const ds = downsampleSeries(histLabels, histRev, mode.step);
        Lh = ds.labels; Rh = ds.values;
      }

      revChart = new Chart(ctx, {
        type,
        data:{
          labels: [...Lh, ...fLabels],
          datasets:[
            { label:'Historical Revenue', data: Rh.concat(Array(fLabels.length).fill(null)), backgroundColor:'rgba(16,185,129,0.7)' },
            { label:'Forecast Revenue', data: Array(Lh.length).fill(null).concat(fRev), backgroundColor:'rgba(37,99,235,0.7)' }
          ]
        },
        options:{
          responsive:true, maintainAspectRatio:false,
          scales:{ 
            y:{ beginAtZero:true, ticks:{ callback:(v)=> v>=1000000? (v/1000000)+'M' : v>=1000? (v/1000)+'k' : v } }, 
            x:{ ticks:{ maxRotation:45, autoSkip:true, maxTicksLimit:12 } } 
          },
          plugins:{
            legend:{ labels:{ usePointStyle:true } },
            zoom:{
              pan:{ enabled:true, mode:'x' },
              zoom:{ wheel:{ enabled:true }, pinch:{ enabled:true }, mode:'x' }
            }
          }
        }
      });
    }
  </script>
</body>
</html>
