<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>BuyWise - Smart Purchase Decision Platform</title>

  <!-- Chart.js core -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
  <!-- Zoom/pan plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.2.0/dist/chartjs-plugin-zoom.min.js"></script>
  <!-- Matrix (heatmap) plugin -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@2.0.1/dist/chartjs-chart-matrix.min.js"></script>

<style>
* { box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
  margin: 0;
  padding: 16px;
  color: #1e293b;
  line-height: 1.6;
}

.container {
  max-width: 1400px;
  margin: 0 auto;
  padding: 0 16px;
}

.card {
  background: #ffffff;
  border: 1px solid #e2e8f0;
  border-radius: 16px;
  padding: 24px;
  margin-bottom: 24px;
  box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.card:hover {
  transform: translateY(-2px);
  box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.15), 0 10px 20px -5px rgba(0, 0, 0, 0.08);
}

.header {
  text-align: center;
  padding: 32px 24px;
  background: linear-gradient(135deg, #4b0082 0%, #663399 50%, #7b68ee 100%);
  color: white;
  border: none;
  margin-bottom: 32px;
}

h1 {
  margin: 0 0 12px;
  font-size: 2.5rem;
  font-weight: 800;
  letter-spacing: -0.025em;
}

.date-info {
  text-align: center;
  color: #4b0082;
  font-size: 1rem;
  margin-bottom: 24px;
  padding: 16px;
  background: #ede7f6;
  border-radius: 12px;
  border: 1px solid #663399;
}

.grid {
  display: grid;
  gap: 20px;
}

.form-grid {
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 20px;
}

.input-group {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

label {
  font-size: 0.875rem;
  font-weight: 600;
  color: #4b0082;
  margin-bottom: 4px;
}

select, input[type="month"], input[type="number"] {
  padding: 12px 16px;
  border: 2px solid #663399;
  border-radius: 12px;
  outline: none;
  font-size: 1rem;
  background: #ffffff;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
  color: #4527a0;
}

select:focus, input[type="month"]:focus, input[type="number"]:focus {
  border-color: #7b68ee;
  box-shadow: 0 0 0 3px rgba(123, 104, 238, 0.3);
}

select:disabled {
  background: #ede7f6;
  color: #b39ddb;
  cursor: not-allowed;
}

button {
  padding: 14px 28px;
  border: none;
  border-radius: 12px;
  background: linear-gradient(135deg, #4b0082 0%, #7b68ee 100%);
  color: #f3e5f5;
  font-weight: 700;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
  margin-top: 16px;
  box-shadow: 0 0 10px rgba(90, 0, 130, 0.7);
}

button:hover:not(:disabled) {
  transform: translateY(-1px);
  box-shadow: 0 10px 20px -5px rgba(90, 0, 130, 0.8);
}

button:disabled {
  background: #b0a4d4;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.messages {
  margin: 16px 0;
}

.msg {
  display: none;
  padding: 12px 16px;
  border-radius: 12px;
  text-align: center;
  font-weight: 500;
}

.error {
  background: #f3e5f5;
  color: #6a1b9a;
  border: 1px solid #ce93d8;
}

.success {
  background: #ede7f6;
  color: #4b0082;
  border: 1px solid #7e57c2;
}

/* Enhanced Buy Recommendation Styles */
.buy-recommendation {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin: 16px 0;
  padding: 20px;
  border-radius: 12px;
  font-weight: 600;
  font-size: 1.1rem;
}

.buy-recommendation.buy {
  background: linear-gradient(135deg, #4b0082 0%, #7b68ee 100%);
  color: white;
  border: 2px solid #360061;
}

.buy-recommendation.not-buy {
  background: linear-gradient(135deg, #7b68ee 0%, #4b0082 100%);
  color: white;
  border: 2px solid #300044;
}

.buy-recommendation.pending {
  background: #e8e0f7;
  color: #4b0082;
  border: 2px solid #ccc1ee;
}

.buy-probability {
  display: flex;
  align-items: center;
  gap: 12px;
}

.probability-bar {
  width: 100px;
  height: 8px;
  background: rgba(90, 0, 130, 0.3);
  border-radius: 4px;
  overflow: hidden;
}

.probability-fill {
  height: 100%;
  background: rgba(147, 112, 219, 0.9);
  border-radius: 4px;
  transition: width 0.3s ease;
}

/* Personalization Section */
.personalization-section {
  background: linear-gradient(135deg, #ebe6fb 0%, #d6ccfa 100%);
  border: 1px solid #b8aaff;
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 24px;
}

.personalization-title {
  font-size: 1.1rem;
  font-weight: 700;
  color: #4b0082;
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.personalization-title::before {
  content: 'üéØ';
  font-size: 1.2rem;
}

/* Tab Navigation Styles */
.tab-navigation {
  display: flex;
  justify-content: center;
  margin: 32px 0;
  background: #f3ebf9;
  border-radius: 16px;
  padding: 8px;
  box-shadow: 0 4px 15px -5px rgba(75, 0, 130, 0.1);
  overflow-x: auto;
  gap: 4px;
}

.tab-button {
  flex: 1;
  min-width: 140px;
  padding: 16px 24px;
  background: transparent;
  border: none;
  border-radius: 12px;
  font-weight: 600;
  font-size: 0.95rem;
  color: #4b0082;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  white-space: nowrap;
}

.tab-button:hover {
  background: #d9ccf9;
  color: #2e0854;
  transform: translateY(-1px);
}

.tab-button.active {
  background: linear-gradient(135deg, #4b0082 0%, #7b68ee 100%);
  color: #f3e5f5;
  box-shadow: 0 8px 20px -5px rgba(75, 0, 130, 0.4);
}

.tab-button.active:hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 25px -5px rgba(75, 0, 130, 0.5);
}

/* Tab Content Styles */
.tab-content {
  display: none;
  animation: fadeIn 0.3s ease-in-out;
}

.tab-content.active {
  display: block;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.charts-2 {
  grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
  gap: 24px;
}

.charts-3 {
  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
  gap: 24px;
}

@media (max-width: 1200px) {
  .charts-2, .charts-3 {
    grid-template-columns: 1fr;
  }
}

.chart-box {
  height: 400px;
  position: relative;
  background: #e6e0f7;
  border-radius: 12px;
  padding: 16px;
}

@media (min-width: 1400px) {
  .chart-box {
    height: 450px;
  }
}

.chart-title {
  font-size: 1.125rem;
  font-weight: 700;
  margin-bottom: 16px;
  color: #2e0854;
  padding-bottom: 8px;
  border-bottom: 2px solid #b39ddb;
}

.subtle {
  color: #4b0082;
  font-size: 1rem;
  font-weight: 500;
}

.section-title {
  font-size: 1.5rem;
  font-weight: 800;
  margin: 32px 0 20px;
  color: #2e0854;
  padding: 16px 0 12px;
  border-bottom: 3px solid #7b68ee;
  position: relative;
  text-align: center;
}

.section-title::after {
  content: '';
  position: absolute;
  bottom: -3px;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 3px;
  background: linear-gradient(135deg, #4b0082 0%, #7b68ee 100%);
}

.overview-card {
  background: linear-gradient(135deg, #ede7f6 0%, #d6ccfa 100%);
  border-left: 4px solid #4b0082;
  padding: 24px;
  margin-bottom: 32px;
}

.overview-title {
  font-size: 1.25rem;
  font-weight: 700;
  margin-bottom: 12px;
  color: #2e0854;
}

/* Enhanced responsive breakpoints */
@media (max-width: 768px) {
  .container { padding: 0 12px; }
  .card { padding: 16px; margin-bottom: 16px; }
  .header { padding: 24px 16px; }
  h1 { font-size: 2rem; }
  .section-title { font-size: 1.25rem; margin: 24px 0 16px; }
  .chart-box { height: 300px; padding: 12px; }

  .tab-navigation {
    margin: 20px 0;
    padding: 6px;
  }

  .tab-button {
    min-width: 100px;
    padding: 12px 16px;
    font-size: 0.875rem;
  }

  .buy-recommendation {
    flex-direction: column;
    gap: 12px;
    text-align: center;
  }
}

@media (max-width: 480px) {
  .form-grid { grid-template-columns: 1fr; }
  .chart-box { height: 280px; }
  h1 { font-size: 1.75rem; }

  .tab-navigation {
    flex-direction: column;
    gap: 4px;
  }

  .tab-button {
    min-width: unset;
    width: 100%;
  }
}

/* Chart container improvements */
.chart-container {
  position: relative;
  height: 100%;
  width: 100%;
}

/* Tab specific icons */
.tab-button::before {
  content: '';
  display: inline-block;
  width: 20px;
  height: 20px;
  margin-right: 8px;
  vertical-align: middle;
}

.tab-button[data-tab="sales-forecasting"]::before {
  content: 'üìà';
}

.tab-button[data-tab="revenue-analytics"]::before {
  content: 'üí∞';
}

.tab-button[data-tab="performance"]::before {
  content: 'üìä';
}

.tab-button[data-tab="ratings"]::before {
  content: '‚≠ê';
}
</style>
</head>
<body>
  <div class="container">
    <div class="header card">
      <h1>BuyWise</h1>
      <div class="subtle" style="color: #fff;">Smart Purchase Decision Platform - Analytics & AI-Powered Buy Recommendations</div>
    </div>

    {% if min_date and max_date %}
    <div class="date-info">
      <strong>Available Data Range:</strong> {{ min_date }} to {{ max_date }}
    </div>
    {% endif %}

    <div class="card">
      <div class="grid form-grid">
        <div class="input-group">
          <label for="brand">Brand</label>
          <select id="brand" required>
            <option value="">Select Brand</option>
            {% for b in brands %}
              <option value="{{ b }}">{{ b }}</option>
            {% endfor %}
          </select>
        </div>
        <div class="input-group">
          <label for="product">Product</label>
          <select id="product" required disabled>
            <option value="">Select a brand first</option>
          </select>
        </div>
        <div class="input-group">
          <label for="model">Model</label>
          <select id="model" required disabled>
            <option value="">Select a product first</option>
          </select>
        </div>
        <div class="input-group">
          <label for="start-date">Start Date</label>
          <input type="month" id="start-date" required {% if min_date and max_date %} min="{{ min_date }}" max="{{ max_date }}" {% endif %} />
        </div>
        <div class="input-group">
          <label for="end-date">End Date</label>
          <input type="month" id="end-date" required {% if min_date and max_date %} min="{{ min_date }}" max="{{ max_date }}" {% endif %} />
        </div>
      </div>
      
      <!-- Personalization Section -->
      <div class="personalization-section">
        <div class="personalization-title">Personalize Your Analysis</div>
        <div class="grid form-grid">
          <div class="input-group">
            <label for="budget">Budget (Optional)</label>
            <input type="number" id="budget" placeholder="Enter your budget limit" min="0" step="0.01" />
            <small class="subtle">Help us tailor recommendations to your budget</small>
          </div>
          <div class="input-group">
            <label for="priority">Priority Factor</label>
            <select id="priority">
              <option value="balanced">Balanced (Rating + Sales)</option>
              <option value="rating">High Rating Priority</option>
              <option value="value">Best Value Priority</option>
              <option value="popularity">Popularity Priority</option>
            </select>
          </div>
        </div>
      </div>

      <button id="predict-btn">Generate Smart Analysis</button>
      <div class="messages">
        <div id="err" class="msg error"></div>
        <div id="ok" class="msg success"></div>
      </div>
    </div>

    <div id="results" class="card" style="display:none;">
      <!-- Enhanced Overview with Buy Recommendation -->
      <div class="overview-card">
        <div class="overview-title">Smart Purchase Analysis</div>
        <div id="rec-text" class="subtle">Loading forecast results...</div>
        
        <!-- Buy Recommendation Display -->
        <div id="buy-recommendation" class="buy-recommendation pending">
          <span id="buy-message">Analyzing product data for purchase recommendation...</span>
          <div class="buy-probability">
            <span id="buy-probability-text">--</span>
            <div class="probability-bar">
              <div id="probability-fill" class="probability-fill" style="width: 0%"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Tab Navigation -->
      <div class="tab-navigation">
        <button class="tab-button active" data-tab="sales-forecasting">Sales Forecasting</button>
        <button class="tab-button" data-tab="revenue-analytics">Revenue Analytics</button>
        <button class="tab-button" data-tab="performance">Performance Analysis</button>
        <button class="tab-button" data-tab="ratings">Customer Ratings & Buy AI</button>
      </div>

      <!-- Sales Forecasting Tab -->
      <div id="sales-forecasting" class="tab-content active">
        <div class="section-title">Sales Forecasting</div>
        <div class="grid charts-2">
          <div class="card">
            <div class="chart-title">Historical Sales Analysis</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="historicalChart"></canvas>
              </div>
            </div>
          </div>
          <div class="card">
            <div class="chart-title">Future Sales Forecast</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="forecastChart"></canvas>
              </div>
            </div>
          </div>
        </div>
        <div class="grid charts-2">
          <div class="card">
            <div class="chart-title">Seasonal Patterns</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="seasonalityChart"></canvas>
              </div>
            </div>
          </div>
          <div class="card">
            <div class="chart-title">Revenue Overview</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="revenueChart"></canvas>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Revenue Analytics Tab -->
      <div id="revenue-analytics" class="tab-content">
        <div class="section-title">Revenue Analytics</div>
        <div class="grid charts-3">
          <div class="card">
            <div class="chart-title">Revenue Trend Analysis</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="revenueTrendChart"></canvas>
              </div>
            </div>
          </div>
          <div class="card">
            <div class="chart-title">Monthly Revenue Growth</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="revenueGrowthChart"></canvas>
              </div>
            </div>
          </div>
          <div class="card">
            <div class="chart-title">Revenue vs. Quantity</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="revenueQuantityChart"></canvas>
              </div>
            </div>
          </div>
        </div>
        <div class="grid charts-2">
          <div class="card">
            <div class="chart-title">Cumulative Revenue</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="cumulativeRevenueChart"></canvas>
              </div>
            </div>
          </div>
          <div class="card">
            <div class="chart-title">Average Revenue per Unit</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="avgRevenueChart"></canvas>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Performance Analysis Tab -->
      <div id="performance" class="tab-content">
        <div class="section-title">Performance Analysis</div>
        <div class="grid charts-2">
          <div class="card">
            <div class="chart-title">Year-over-Year Growth</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="yoyChart"></canvas>
              </div>
            </div>
          </div>
          <div class="card">
            <div class="chart-title">Price vs. Sales Correlation</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="priceSalesChart"></canvas>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Enhanced Customer Ratings Tab -->
      <div id="ratings" class="tab-content">
        <div class="section-title">Customer Ratings & AI Purchase Recommendation</div>
        
        <!-- AI Recommendation Summary -->
        <div class="card" style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-color: #f59e0b;">
          <div class="chart-title" style="color: #92400e;">ü§ñ AI Purchase Recommendation Summary</div>
          <div id="ai-summary" class="subtle" style="color: #78350f; font-size: 1.1rem; line-height: 1.8;">
            Analyzing customer ratings, sales performance, and market trends to generate personalized recommendation...
          </div>
        </div>

        <div class="grid charts-2">
          <div class="card">
            <div class="chart-title">Rating Trends Over Time</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="ratingTrendChart"></canvas>
              </div>
            </div>
          </div>
          <div class="card">
            <div class="chart-title">Rating Distribution</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="ratingDistChart"></canvas>
              </div>
            </div>
          </div>
        </div>
        <div class="grid charts-2">
          <div class="card">
            <div class="chart-title">Ratings vs. Sales Performance</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="ratingsSalesChart"></canvas>
              </div>
            </div>
          </div>
          <div class="card">
            <div class="chart-title">Sentiment Analysis</div>
            <div class="chart-box">
              <div class="chart-container">
                <canvas id="sentimentChart"></canvas>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Enhanced Chart defaults
    Chart.defaults.font.family = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif";
    Chart.defaults.font.size = 12;
    Chart.defaults.plugins.legend.labels.usePointStyle = true;
    Chart.defaults.plugins.legend.labels.padding = 20;
    Chart.defaults.plugins.tooltip.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    Chart.defaults.plugins.tooltip.titleColor = '#ffffff';
    Chart.defaults.plugins.tooltip.bodyColor = '#ffffff';
    Chart.defaults.plugins.tooltip.cornerRadius = 8;
    Chart.defaults.plugins.tooltip.padding = 12;

    // Elements
    const brandEl = document.getElementById('brand');
    const productEl = document.getElementById('product');
    const modelEl = document.getElementById('model');
    const startEl = document.getElementById('start-date');
    const endEl = document.getElementById('end-date');
    const budgetEl = document.getElementById('budget');
    const priorityEl = document.getElementById('priority');
    const predictBtn = document.getElementById('predict-btn');
    const errEl = document.getElementById('err');
    const okEl = document.getElementById('ok');
    const resultsEl = document.getElementById('results');
    const recEl = document.getElementById('rec-text');
    const buyRecommendationEl = document.getElementById('buy-recommendation');
    const buyMessageEl = document.getElementById('buy-message');
    const buyProbabilityTextEl = document.getElementById('buy-probability-text');
    const probabilityFillEl = document.getElementById('probability-fill');
    const aiSummaryEl = document.getElementById('ai-summary');

    const MIN_DATE = '{{ min_date }}';
    const MAX_DATE = '{{ max_date }}';

    // Charts
    let histChart=null, fcChart=null, seasChart=null, revChart=null, 
        yoyChart=null, priceSalesChart=null,
        ratingTrendChart=null, ratingDistChart=null, ratingsSalesChart=null, sentimentChart=null,
        revenueTrendChart=null, revenueGrowthChart=null, revenueQuantityChart=null,
        cumulativeRevenueChart=null, avgRevenueChart=null;

    // Tab Management
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabContents = document.querySelectorAll('.tab-content');

    tabButtons.forEach(button => {
      button.addEventListener('click', () => {
        const targetTab = button.getAttribute('data-tab');
        
        // Remove active class from all buttons and contents
        tabButtons.forEach(btn => btn.classList.remove('active'));
        tabContents.forEach(content => content.classList.remove('active'));
        
        // Add active class to clicked button and corresponding content
        button.classList.add('active');
        document.getElementById(targetTab).classList.add('active');
        
        // Trigger chart resize to ensure proper rendering when tab becomes visible
        setTimeout(() => {
          Chart.helpers.each(Chart.instances, (instance) => {
            if (instance.chart.canvas.offsetParent !== null) {
              instance.resize();
            }
          });
        }, 50);
      });
    });

    // Enhanced zoom options
    const getZoomOptions = (enableX = true, enableY = false) => ({
      zoom: {
        wheel: { enabled: true, speed: 0.1 },
        pinch: { enabled: true },
        mode: enableX && enableY ? 'xy' : enableX ? 'x' : 'y'
      },
      pan: {
        enabled: true,
        mode: enableX && enableY ? 'xy' : enableX ? 'x' : 'y',
        threshold: 10
      }
    });

    // Color palette
    const colors = {
      primary: '#6366f1',
      secondary: '#8b5cf6',
      success: '#10b981',
      warning: '#f59e0b',
      danger: '#ef4444',
      info: '#3b82f6',
      purple: '#a855f7',
      teal: '#14b8a6'
    };

    // Data processing for large datasets
    const processLargeDataset = (labels, values, maxPoints = 100) => {
      if (labels.length <= maxPoints) return { labels, values };
      
      const step = Math.ceil(labels.length / maxPoints);
      const processedLabels = [];
      const processedValues = [];
      
      for (let i = 0; i < labels.length; i += step) {
        processedLabels.push(labels[i]);
        processedValues.push(values[i]);
      }
      
      return { labels: processedLabels, values: processedValues };
    };

    // Update Buy Recommendation Display
// Update Buy Recommendation Display
function updateBuyRecommendation(ratingsData) {
  if (!ratingsData) return;

  const buyRec = ratingsData.buy_recommendation || 'Model not trained';
  const buyProb = ratingsData.buy_probability || 0;

  // Update recommendation message
  if (buyRec === 'Buy') {
    buyRecommendationEl.className = 'buy-recommendation buy';
    buyMessageEl.textContent = '‚úÖ Recommended Purchase';
  } else if (buyRec.includes('Do not buy') || buyRec.startsWith('Do not buy')) {
    buyRecommendationEl.className = 'buy-recommendation not-buy';
    buyMessageEl.textContent = '‚ùå Not Recommended';
  } else {
    buyRecommendationEl.className = 'buy-recommendation pending';
    buyMessageEl.textContent = '‚ö†Ô∏è ' + buyRec;
  }

  // Update probability display
  if (typeof buyProb === 'number' && buyProb > 0) {
    buyProbabilityTextEl.textContent = `${(buyProb * 100).toFixed(1)}%`;
    probabilityFillEl.style.width = `${buyProb * 100}%`;
  } else {
    buyProbabilityTextEl.textContent = '--';
    probabilityFillEl.style.width = '0%';
  }

  // Update AI summary
  generateAISummary(ratingsData);
}

    // Generate AI Summary
// Generate AI Summary
function generateAISummary(ratingsData) {
  const buyRec = ratingsData.buy_recommendation || 'Model not trained';
  const buyProb = ratingsData.buy_probability || 0;
  const sentimentData = ratingsData.sentiment_breakdown;
  
  let summary = `Based on our AI analysis of customer ratings and sales performance: `;
  
  if (buyRec === 'Buy') {
    summary += `This product shows strong positive indicators with a ${(buyProb * 100).toFixed(1)}% confidence score. `;
    
    // Fixed: Check if sentimentData exists and has valid values
    if (sentimentData && sentimentData.values && Array.isArray(sentimentData.values) && sentimentData.values.length > 0) {
      const positivePercent = sentimentData.values[0];
      if (typeof positivePercent === 'number' && positivePercent > 60) {
        summary += `Customer sentiment is highly positive (${positivePercent.toFixed(1)}% positive reviews), `;
      }
    }
    summary += `making it a recommended purchase for your consideration.`;
    
  } else if (buyRec.includes('Do not buy')) {
    summary += `Our analysis suggests caution with a ${(buyProb * 100).toFixed(1)}% confidence score. `;
    
    // Fixed: Check if sentimentData exists and has valid values
    if (sentimentData && sentimentData.values && Array.isArray(sentimentData.values) && sentimentData.values.length > 2) {
      const negativePercent = sentimentData.values[2];
      if (typeof negativePercent === 'number' && negativePercent > 30) {
        summary += `Higher negative sentiment detected (${negativePercent.toFixed(1)}% negative reviews), `;
      }
    }
    summary += `indicating potential concerns with this product.`;
    
  } else {
    summary += `Insufficient data for reliable AI prediction. Consider gathering more product information before making a purchase decision.`;
  }

  // Add budget consideration if provided
  const budget = budgetEl.value;
  if (budget && buyRec.includes('budget')) {
    summary += ` Note: This recommendation considers your specified budget of $${budget}.`;
  }

  aiSummaryEl.textContent = summary;
}

    // Defaults for dates
    (function setDefaults(){
      if (MIN_DATE && MAX_DATE) {
        const maxDate = new Date(MAX_DATE + '-01');
        const minDate = new Date(MIN_DATE + '-01');
        const defaultStart = new Date(maxDate);
        defaultStart.setMonth(defaultStart.getMonth() - 6);
        startEl.value = (defaultStart < minDate) ? MIN_DATE : defaultStart.toISOString().slice(0,7);
        endEl.value = MAX_DATE;
      }
    })();

    // Helper functions
    function showError(msg){ 
      errEl.textContent = msg; 
      errEl.style.display = 'block'; 
      okEl.style.display = 'none'; 
      errEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
    
    function showOk(msg){ 
      okEl.textContent = msg; 
      okEl.style.display = 'block'; 
      errEl.style.display = 'none'; 
    }
    
    function clearMsgs(){ 
      errEl.style.display = 'none'; 
      okEl.style.display = 'none'; 
    }

    function validateDates(){
      const s=startEl.value, e=endEl.value;
      if (!s || !e) return false;
      if (s >= e){ showError('End date must be after start date.'); return false; }
      if (MIN_DATE && s < MIN_DATE){ showError(`Start date must be ‚â• ${MIN_DATE}.`); return false; }
      if (MAX_DATE && e > MAX_DATE){ showError(`End date must be ‚â§ ${MAX_DATE}.`); return false; }
      return true;
    }

    function populateSelect(sel, items, placeholder){
      sel.innerHTML='';
      if (items && items.length){
        sel.add(new Option(placeholder,''));
        items.forEach(v=>sel.add(new Option(v,v)));
        sel.disabled=false;
      } else {
        sel.add(new Option(`No ${placeholder.toLowerCase()} found`, ''));
        sel.disabled=true;
      }
    }

    // Data processing functions
    function downsampleSeries(labels, values, step) {
      if (step <= 1) return { labels, values };
      const dsL = [], dsV = [];
      for (let i = 0; i < labels.length; i += step) {
        dsL.push(labels[i]);
        dsV.push(values[i]);
      }
      return { labels: dsL, values: dsV };
    }

    function toQuarterly(labels, values) {
      const outL = [], outV = [];
      let qSum = 0, currentQ = null;
      for (let i = 0; i < labels.length; i++) {
        const [y, m] = labels[i].split('-').map(Number);
        const q = Math.floor((m - 1) / 3) + 1;
        const tag = `${y}-Q${q}`;
        if (currentQ === null) currentQ = tag;
        if (tag !== currentQ) {
          outL.push(currentQ);
          outV.push(qSum);
          qSum = 0; currentQ = tag;
        }
        qSum += Number(values[i] || 0);
      }
      if (currentQ !== null) {
        outL.push(currentQ);
        outV.push(qSum);
      }
      return { labels: outL, values: outV };
    }

    function pickScaleMode(labels) {
      if (!labels.length) return { mode: 'monthly', step: 1 };
      
      const dataPoints = labels.length;
      if (dataPoints > 200) return { mode: 'quarterly' };
      if (dataPoints > 100) return { mode: 'monthly', step: 4 };
      if (dataPoints > 60) return { mode: 'monthly', step: 2 };
      
      const startY = Number(labels[0].slice(0,4));
      const endY = Number(labels[labels.length-1].slice(0,4));
      const span = endY - startY + 1;
      
      if (span >= 12) return { mode: 'quarterly' };
      if (span >= 6) return { mode: 'monthly', step: 3 };
      if (span >= 3) return { mode: 'monthly', step: 2 };
      return { mode: 'monthly', step: 1 };
    }

    function heatmapColor(value, vmax) {
      if (!vmax || vmax <= 0) return 'rgba(229,231,235,1)';
      const t = Math.max(0, Math.min(1, value / vmax));
      const stops = [
        [237,233,254], [221,214,254], [196,181,253], [167,139,250], [124, 58,237],
      ];
      const idx = Math.min(stops.length - 1, Math.floor(t * (stops.length - 1)));
      const [r,g,b] = stops[idx];
      return `rgba(${r},${g},${b},1)`;
    }

    // Common chart options
    const getCommonChartOptions = (title, hasZoom = true) => ({
      responsive: true,
      maintainAspectRatio: false,
      interaction: { intersect: false, mode: 'index' },
      plugins: {
        legend: {
          display: true,
          position: 'top',
          labels: {
            usePointStyle: true,
            padding: 20,
            font: { size: 12, weight: '600' }
          }
        },
        tooltip: {
          backgroundColor: 'rgba(0, 0, 0, 0.8)',
          titleColor: '#ffffff',
          bodyColor: '#ffffff',
          cornerRadius: 8,
          padding: 12,
          displayColors: true,
          callbacks: {
            label: function(context) {
              let label = context.dataset.label || '';
              if (label) label += ': ';
              const value = context.parsed.y;
              if (value >= 1000000) {
                label += (value / 1000000).toFixed(1) + 'M';
              } else if (value >= 1000) {
                label += (value / 1000).toFixed(1) + 'k';
              } else {
                label += value.toLocaleString();
              }
              return label;
            }
          }
        },
        ...(hasZoom && { zoom: getZoomOptions(true, false) })
      },
      scales: {
        y: {
          beginAtZero: true,
          grid: { color: 'rgba(0, 0, 0, 0.1)', lineWidth: 1 },
          ticks: {
            font: { size: 11 },
            color: '#64748b',
            padding: 8,
            callback: function(value) {
              if (value >= 1000000) return (value / 1000000).toFixed(1) + 'M';
              if (value >= 1000) return (value / 1000).toFixed(1) + 'k';
              return value.toLocaleString();
            }
          }
        },
        x: {
          grid: { display: false },
          ticks: {
            font: { size: 11 },
            color: '#64748b',
            maxRotation: 45,
            autoSkip: true,
            maxTicksLimit: 12,
            padding: 8
          }
        }
      }
    });

    // Event listeners
    brandEl.addEventListener('change', async function(){
      clearMsgs();
      const b=this.value;
      productEl.disabled=true; modelEl.disabled=true;
      productEl.innerHTML='<option value="">Loading...</option>';
      modelEl.innerHTML='<option value="">Select a product first</option>';
      if (!b){ productEl.innerHTML='<option value="">Select a brand first</option>'; return; }
      try{
        const r=await fetch(`/api/products/${encodeURIComponent(b)}`);
        if(!r.ok) throw new Error('Failed to fetch products');
        const products=await r.json();
        populateSelect(productEl, products, 'Select Product');
        modelEl.innerHTML='<option value="">Select a product first</option>';
        modelEl.disabled=true;
      }catch(e){ showError(e.message); productEl.innerHTML='<option value="">Error loading products</option>'; productEl.disabled=true; }
    });

    productEl.addEventListener('change', async function(){
      clearMsgs();
      const b=brandEl.value, p=this.value;
      modelEl.disabled=true; modelEl.innerHTML='<option value="">Loading...</option>';
      if (!b || !p){ modelEl.innerHTML='<option value="">Select brand and product first</option>'; return; }
      try{
        const r=await fetch(`/api/models/${encodeURIComponent(b)}/${encodeURIComponent(p)}`);
        if(!r.ok) throw new Error('Failed to fetch models');
        const models=await r.json();
        populateSelect(modelEl, models, 'Select Model');
      }catch(e){ showError(e.message); modelEl.innerHTML='<option value="">Error loading models</option>'; modelEl.disabled=true; }
    });

    // Enhanced Predict function with personalization
    predictBtn.addEventListener('click', async function(){
      clearMsgs();
      const b=brandEl.value, p=productEl.value, m=modelEl.value, s=startEl.value, e=endEl.value;
      if(!b||!p||!m||!s||!e){ showError('Please fill in all required fields.'); return; }
      if(!validateDates()) return;
      
      predictBtn.disabled=true;
      predictBtn.textContent='Generating AI Analysis...';
      
      // Reset buy recommendation to pending
      buyRecommendationEl.className = 'buy-recommendation pending';
      buyMessageEl.textContent = 'Analyzing product data...';
      buyProbabilityTextEl.textContent = '--';
      probabilityFillEl.style.width = '0%';
      
      try{
        // Prepare request data with personalization
        const requestData = {
          brand: b,
          product: p,
          model: m,
          start_date: s + '-01',
          end_date: e + '-01'
        };

        // Add personalization parameters if provided
        if (budgetEl.value) {
          requestData.budget = parseFloat(budgetEl.value);
        }
        if (priorityEl.value) {
          requestData.priority = priorityEl.value;
        }

        const [forecastResponse, ratingsResponse] = await Promise.allSettled([
          fetch('/api/forecast', {
            method:'POST', 
            headers:{'Content-Type':'application/json','Accept':'application/json'},
            body:JSON.stringify(requestData)
          }),
          fetch('/api/ratings', {
            method:'POST', 
            headers:{'Content-Type':'application/json','Accept':'application/json'},
            body:JSON.stringify(requestData)
          })
        ]);

        const data = forecastResponse.status === 'fulfilled' && forecastResponse.value.ok 
          ? await forecastResponse.value.json() 
          : null;
        
        const ratingsData = ratingsResponse.status === 'fulfilled' && ratingsResponse.value.ok 
          ? await ratingsResponse.value.json() 
          : null;

        if (!data) throw new Error('Failed to get forecast data');

        renderAll(data, ratingsData);
        updateBuyRecommendation(ratingsData);
        resultsEl.style.display='block';
        showOk('AI analysis completed! Smart purchase recommendation generated based on data and your preferences.');
        
        setTimeout(() => {
          resultsEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }, 100);
        
      }catch(err){ 
        showError(err.message || 'An error occurred while generating the AI analysis.'); 
        // Reset to pending state
        buyRecommendationEl.className = 'buy-recommendation pending';
        buyMessageEl.textContent = 'Analysis failed - please try again';
      }
      finally{ 
        predictBtn.disabled=false; 
        predictBtn.textContent='Generate Smart Analysis';
      }
    });

    // Enhanced renderAll function
    function renderAll(data, ratingsData){
      recEl.textContent = data?.recommendation?.message || 'Forecast analysis completed successfully.';
      
      // Render all charts
      renderHistorical(data);
      renderForecast(data);
      renderSeasonality(data?.seasonality||[]);
      renderRevenue(data);
      
      // Revenue analytics
      renderRevenueTrend(data);
      renderRevenueGrowth(data);
      renderRevenueQuantity(data);
      renderCumulativeRevenue(data);
      renderAvgRevenue(data);
      
      // Performance analysis
      renderYearOverYear(data);
      renderPriceSalesCorrelation(data);
      
      // Ratings analysis
      if (ratingsData) {
        renderRatingTrend(ratingsData);
        renderRatingDistribution(ratingsData);
        renderRatingsVsSales(ratingsData);
        renderSentimentChart(ratingsData);
      } else {
        renderEmptyRatingCharts();
      }
    }

    // Chart rendering functions
    function renderHistorical(data){
      const ctx=document.getElementById('historicalChart').getContext('2d');
      if(histChart) histChart.destroy();
      
      const labels=data?.history?.labels||[];
      const values=data?.history?.values||[];
      
      if (!labels.length) {
        histChart = new Chart(ctx, { 
          type: 'line', 
          data: { labels: [], datasets: [] }, 
          options: getCommonChartOptions('Historical Sales')
        });
        return;
      }

      const mode = pickScaleMode(labels);
      let L = labels, V = values, type='line', datasets;

      if (mode.mode === 'quarterly') {
        const q = toQuarterly(labels, values);
        L = q.labels; V = q.values; type='bar';
      } else if (mode.step > 1) {
        const ds = downsampleSeries(labels, values, mode.step);
        L = ds.labels; V = ds.values;
      }

      if (type==='line') {
        const ma = (arr, w) => arr.map((_,i)=> i+1<w ? null : Math.round(arr.slice(i-w+1,i+1).reduce((a,b)=>a+Number(b||0),0)/w));
        const ma3 = ma(V,3), ma6 = ma(V,6), ma12 = ma(V,12);
        datasets = [
          { 
            label:'Historical Sales', 
            data:V, 
            borderColor: colors.primary, 
            backgroundColor: colors.primary + '20', 
            fill: true, 
            tension: 0.4,
            borderWidth: 3,
            pointRadius: L.length > 50 ? 0 : 3,
            pointHoverRadius: 6
          },
          { 
            label:'3-Month Average', 
            data:ma3, 
            borderColor: colors.success, 
            borderDash:[8,4], 
            tension: 0.4,
            borderWidth: 2,
            pointRadius: 0
          },
          { 
            label:'6-Month Average', 
            data:ma6, 
            borderColor: colors.warning, 
            borderDash:[8,4], 
            tension: 0.4,
            borderWidth: 2,
            pointRadius: 0
          },
          { 
            label:'12-Month Average', 
            data:ma12, 
            borderColor: colors.danger, 
            borderDash:[8,4], 
            tension: 0.4,
            borderWidth: 2,
            pointRadius: 0
          }
        ];
      } else {
        datasets = [
          { 
            label:'Historical Sales (Quarterly)', 
            data:V, 
            backgroundColor: colors.primary + 'CC', 
            borderColor: colors.primary,
            borderWidth: 2
          }
        ];
      }

      histChart = new Chart(ctx, {
        type,
        data: { labels: L, datasets },
        options: getCommonChartOptions('Historical Sales Analysis')
      });
    }

    function renderForecast(data){
      const ctx=document.getElementById('forecastChart').getContext('2d');
      if(fcChart) fcChart.destroy();
      
      const labels=data?.forecast?.labels||[];
      const vals=data?.forecast?.values||[];
      const highs=data?.forecast?.highs||[];
      const lows=data?.forecast?.lows||[];

      if (!labels.length) {
        fcChart = new Chart(ctx, { 
          type: 'line', 
          data: { labels: [], datasets: [] }, 
          options: getCommonChartOptions('Forecast')
        });
        return;
      }

      fcChart = new Chart(ctx, {
        type:'line',
        data:{
          labels,
          datasets:[
            { 
              label:'Upper Confidence', 
              data:highs, 
              borderColor: colors.secondary + '80', 
              backgroundColor: colors.secondary + '20', 
              fill:'+1', 
              pointRadius:0, 
              tension:0.4,
              borderWidth: 2
            },
            { 
              label:'Lower Confidence', 
              data:lows,  
              borderColor: colors.secondary + '80', 
              backgroundColor: colors.secondary + '20', 
              fill:'-1', 
              pointRadius:0, 
              tension:0.4,
              borderWidth: 2
            },
            { 
              label:'Forecast', 
              data:vals, 
              borderColor: colors.info, 
              backgroundColor: colors.info + '20', 
              fill:false, 
              tension:0.4,
              borderWidth: 3,
              pointRadius: 4,
              pointHoverRadius: 8
            }
          ]
        },
        options: getCommonChartOptions('Sales Forecast')
      });
    }

    function renderSeasonality(heat){
      const ctx=document.getElementById('seasonalityChart').getContext('2d');
      if(seasChart) seasChart.destroy();

      if (!Array.isArray(heat) || !heat.length) {
        seasChart = new Chart(ctx, { 
          type:'bar', 
          data:{ labels:[], datasets:[] }, 
          options: getCommonChartOptions('Seasonality', false)
        });
        return;
      }

      const years = [...new Set(heat.map(h=>h.year))].sort((a,b)=>a-b);
      let vmax = Math.max(...heat.map(h => h.value));

      const yIndex = (y) => years.indexOf(y);
      const matrixData = heat.map(h => ({
        x: h.month - 1,
        y: yIndex(h.year),
        v: h.value,
        w: Math.max(18, Math.min(30, 400 / Math.max(12, years.length))),
        h: Math.max(18, Math.min(30, 400 / Math.max(12, years.length)))
      }));

      seasChart = new Chart(ctx, {
        type: 'matrix',
        data: {
          datasets: [{
            label: 'Sales Volume',
            data: matrixData,
            backgroundColor: ctx => heatmapColor(ctx.raw.v, vmax),
            borderColor: 'rgba(255,255,255,0.8)',
            borderWidth: 1,
            width: ctx => ctx.raw.w,
            height: ctx => ctx.raw.h
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#ffffff',
              bodyColor: '#ffffff',
              cornerRadius: 8,
              padding: 12,
              callbacks: {
                title: () => '',
                label: ctx => {
                  const mIdx = ctx.raw.x;
                  const year = years[ctx.raw.y];
                  const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                  return `${monthNames[mIdx]} ${year}: ${ctx.raw.v.toLocaleString()} units`;
                }
              }
            },
            zoom: getZoomOptions(true, true)
          },
          scales: {
            x: {
              type: 'linear',
              position: 'top',
              min: -0.5,
              max: 11.5,
              ticks: {
                callback: (v) => ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'][v],
                maxRotation: 0,
                autoSkip: false,
                font: { size: 11 },
                color: '#64748b'
              },
              grid: { display: false }
            },
            y: {
              type: 'linear',
              min: -0.5,
              max: years.length - 0.5,
              ticks: { 
                callback: (v) => years[v] ?? '', 
                autoSkip: false,
                font: { size: 11 },
                color: '#64748b'
              },
              reverse: true,
              grid: { display: false }
            }
          }
        }
      });
    }

    function renderRevenue(data){
      const ctx=document.getElementById('revenueChart').getContext('2d');
      if(revChart) revChart.destroy();
      
      const histLabels=data?.history?.labels||[];
      const histRev=data?.history?.revenue||[];
      const fLabels=data?.forecast?.labels||[];
      const fRev=data?.forecast?.revenue||[];

      if (!histLabels.length && !fLabels.length) {
        revChart = new Chart(ctx, { 
          type: 'bar', 
          data: { labels: [], datasets: [] }, 
          options: getCommonChartOptions('Revenue')
        });
        return;
      }

      const mode = pickScaleMode(histLabels);
      let Lh=histLabels, Rh=histRev, type='bar';

      if (mode.mode === 'quarterly') {
        const q = toQuarterly(histLabels, histRev);
        Lh = q.labels; Rh = q.values;
      } else if (mode.step > 1) {
        const ds = downsampleSeries(histLabels, histRev, mode.step);
        Lh = ds.labels; Rh = ds.values;
      }

      revChart = new Chart(ctx, {
        type,
        data:{
          labels: [...Lh, ...fLabels],
          datasets:[
            { 
              label:'Historical Revenue', 
              data: Rh.concat(Array(fLabels.length).fill(null)), 
              backgroundColor: colors.success + 'CC',
              borderColor: colors.success,
              borderWidth: 2
            },
            { 
              label:'Forecast Revenue', 
              data: Array(Lh.length).fill(null).concat(fRev), 
              backgroundColor: colors.info + 'CC',
              borderColor: colors.info,
              borderWidth: 2
            }
          ]
        },
        options: getCommonChartOptions('Revenue Analysis')
      });
    }

    function renderRevenueTrend(data){
      const ctx=document.getElementById('revenueTrendChart').getContext('2d');
      if(revenueTrendChart) revenueTrendChart.destroy();
      
      const labels = data?.history?.labels || [];
      const revenues = data?.history?.revenue || [];
      
      if (!labels.length) {
        revenueTrendChart = new Chart(ctx, { 
          type: 'line', 
          data: { labels: [], datasets: [] }, 
          options: getCommonChartOptions('Revenue Trend')
        });
        return;
      }
      
      const processed = processLargeDataset(labels, revenues);
      const ma3 = processed.values.map((_,i)=> i+2<processed.values.length ? Math.round(processed.values.slice(i,i+3).reduce((a,b)=>a+Number(b||0),0)/3) : null);
      const ma6 = processed.values.map((_,i)=> i+5<processed.values.length ? Math.round(processed.values.slice(i,i+6).reduce((a,b)=>a+Number(b||0),0)/6) : null);

      revenueTrendChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: processed.labels,
          datasets: [
            { 
              label: 'Revenue', 
              data: processed.values, 
              borderColor: colors.success, 
              backgroundColor: colors.success + '20', 
              fill: true, 
              tension: 0.4,
              borderWidth: 3,
              pointRadius: processed.labels.length > 50 ? 0 : 3
            },
            { 
              label: '3-Period Average', 
              data: ma3, 
              borderColor: colors.warning, 
              borderDash: [8,4], 
              tension: 0.4,
              borderWidth: 2,
              pointRadius: 0
            },
            { 
              label: '6-Period Average', 
              data: ma6, 
              borderColor: colors.danger, 
              borderDash: [8,4], 
              tension: 0.4,
              borderWidth: 2,
              pointRadius: 0
            }
          ]
        },
        options: getCommonChartOptions('Revenue Trend Analysis')
      });
    }

    function renderRevenueGrowth(data){
      const ctx=document.getElementById('revenueGrowthChart').getContext('2d');
      if(revenueGrowthChart) revenueGrowthChart.destroy();
      
      const labels = data?.history?.labels || [];
      const revenues = data?.history?.revenue || [];
      
      if (labels.length < 2) {
        revenueGrowthChart = new Chart(ctx, { 
          type: 'bar', 
          data: { labels: [], datasets: [] }, 
          options: getCommonChartOptions('Revenue Growth')
        });
        return;
      }
      
      const growthData = [];
      const growthLabels = [];
      
      for (let i = 1; i < revenues.length; i++) {
        const current = revenues[i] || 0;
        const previous = revenues[i-1] || 0;
        if (previous > 0) {
          const growth = ((current - previous) / previous) * 100;
          growthData.push(growth);
          growthLabels.push(labels[i]);
        }
      }

      const processed = processLargeDataset(growthLabels, growthData);
      const options = getCommonChartOptions('Monthly Revenue Growth');
      options.plugins.tooltip.callbacks.label = function(context) {
        return `Growth: ${context.parsed.y.toFixed(1)}%`;
      };
      options.plugins.legend.display = false;

      revenueGrowthChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: processed.labels,
          datasets: [{
            label: 'MoM Growth %',
            data: processed.values,
            backgroundColor: processed.values.map(v => v >= 0 ? colors.success + 'CC' : colors.danger + 'CC'),
            borderColor: processed.values.map(v => v >= 0 ? colors.success : colors.danger),
            borderWidth: 2
          }]
        },
        options: options
      });
    }

    function renderRevenueQuantity(data){
      const ctx=document.getElementById('revenueQuantityChart').getContext('2d');
      if(revenueQuantityChart) revenueQuantityChart.destroy();
      
      const quantities = data?.history?.values || [];
      const revenues = data?.history?.revenue || [];
      
      const scatterData = quantities.map((qty, i) => ({
        x: qty || 0,
        y: revenues[i] || 0
      })).filter(point => point.x > 0 && point.y > 0);

      if (!scatterData.length) {
        revenueQuantityChart = new Chart(ctx, { 
          type: 'scatter', 
          data: { datasets: [] }, 
          options: getCommonChartOptions('Revenue vs Quantity')
        });
        return;
      }

      const options = getCommonChartOptions('Revenue vs Quantity Correlation');
      options.plugins.zoom = getZoomOptions(true, true);
      options.scales.x.title = { display: true, text: 'Quantity Sold', font: { weight: 'bold' } };
      options.scales.y.title = { display: true, text: 'Revenue ($)', font: { weight: 'bold' } };

      revenueQuantityChart = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [{
            label: 'Revenue vs Quantity',
            data: scatterData,
            backgroundColor: colors.success + '99',
            borderColor: colors.success,
            borderWidth: 2,
            pointRadius: 4,
            pointHoverRadius: 8
          }]
        },
        options: options
      });
    }

    function renderCumulativeRevenue(data){
      const ctx=document.getElementById('cumulativeRevenueChart').getContext('2d');
      if(cumulativeRevenueChart) cumulativeRevenueChart.destroy();
      
      const labels = data?.history?.labels || [];
      const revenues = data?.history?.revenue || [];
      
      if (!labels.length) {
        cumulativeRevenueChart = new Chart(ctx, { 
          type: 'line', 
          data: { labels: [], datasets: [] }, 
          options: getCommonChartOptions('Cumulative Revenue')
        });
        return;
      }
      
      let cumulative = 0;
      const cumulativeData = revenues.map(rev => {
        cumulative += (rev || 0);
        return cumulative;
      });

      const processed = processLargeDataset(labels, cumulativeData);

      cumulativeRevenueChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: processed.labels,
          datasets: [{
            label: 'Cumulative Revenue',
            data: processed.values,
            borderColor: colors.purple,
            backgroundColor: colors.purple + '20',
            fill: true,
            tension: 0.4,
            borderWidth: 3,
            pointRadius: processed.labels.length > 50 ? 0 : 3,
            pointHoverRadius: 6
          }]
        },
        options: getCommonChartOptions('Cumulative Revenue')
      });
    }

    function renderAvgRevenue(data){
      const ctx=document.getElementById('avgRevenueChart').getContext('2d');
      if(avgRevenueChart) avgRevenueChart.destroy();
      
      const labels = data?.history?.labels || [];
      const quantities = data?.history?.values || [];
      const revenues = data?.history?.revenue || [];
      
      if (!labels.length) {
        avgRevenueChart = new Chart(ctx, { 
          type: 'line', 
          data: { labels: [], datasets: [] }, 
          options: getCommonChartOptions('Average Revenue per Unit')
        });
        return;
      }
      
      const avgRevenueData = quantities.map((qty, i) => {
        const rev = revenues[i] || 0;
        return qty > 0 ? rev / qty : 0;
      });

      const processed = processLargeDataset(labels, avgRevenueData);
      const options = getCommonChartOptions('Average Revenue per Unit');
      options.scales.y.title = { display: true, text: 'Revenue per Unit ($)', font: { weight: 'bold' } };

      avgRevenueChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: processed.labels,
          datasets: [{
            label: 'Avg Revenue per Unit',
            data: processed.values,
            borderColor: colors.warning,
            backgroundColor: colors.warning + '20',
            fill: true,
            tension: 0.4,
            borderWidth: 3,
            pointRadius: processed.labels.length > 50 ? 0 : 3,
            pointHoverRadius: 6
          }]
        },
        options: options
      });
    }

    function renderYearOverYear(data){
      const ctx=document.getElementById('yoyChart').getContext('2d');
      if(yoyChart) yoyChart.destroy();
      
      const labels = data?.history?.labels || [];
      const values = data?.history?.values || [];
      
      if (labels.length < 12) {
        const options = getCommonChartOptions('Year-over-Year Growth');
        options.plugins.title = { display: true, text: 'Insufficient data for YoY analysis (need 12+ months)' };
        yoyChart = new Chart(ctx, { 
          type: 'line', 
          data: { labels: [], datasets: [] }, 
          options: options
        });
        return;
      }
      
      const yoyGrowth = [];
      const yoyLabels = [];
      
      for (let i = 12; i < labels.length; i++) {
        const currentValue = values[i] || 0;
        const previousYearValue = values[i - 12] || 0;
        if (previousYearValue > 0) {
          const growth = ((currentValue - previousYearValue) / previousYearValue) * 100;
          yoyGrowth.push(growth);
          yoyLabels.push(labels[i]);
        }
      }

      const processed = processLargeDataset(yoyLabels, yoyGrowth);
      const options = getCommonChartOptions('Year-over-Year Growth');
      options.scales.y.title = { display: true, text: 'Growth (%)', font: { weight: 'bold' } };
      options.plugins.tooltip.callbacks.label = function(context) {
        return `YoY Growth: ${context.parsed.y.toFixed(1)}%`;
      };

      yoyChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: processed.labels,
          datasets: [{
            label: 'YoY Growth %',
            data: processed.values,
            borderColor: colors.success,
            backgroundColor: colors.success + '20',
            fill: true,
            tension: 0.4,
            borderWidth: 3,
            pointRadius: processed.labels.length > 50 ? 0 : 4,
            pointHoverRadius: 8
          }]
        },
        options: options
      });
    }

    function renderPriceSalesCorrelation(data){
      const ctx=document.getElementById('priceSalesChart').getContext('2d');
      if(priceSalesChart) priceSalesChart.destroy();
      
      const labels = data?.history?.labels || [];
      const quantities = data?.history?.values || [];
      const revenues = data?.history?.revenue || [];
      
      const scatterData = [];
      for (let i = 0; i < labels.length; i++) {
        const qty = quantities[i] || 0;
        const rev = revenues[i] || 0;
        if (qty > 0 && rev > 0) {
          const avgPrice = rev / qty;
          scatterData.push({ x: avgPrice, y: qty });
        }
      }

      if (!scatterData.length) {
        priceSalesChart = new Chart(ctx, { 
          type: 'scatter', 
          data: { datasets: [] }, 
          options: getCommonChartOptions('Price vs Sales')
        });
        return;
      }

      const options = getCommonChartOptions('Price vs Sales Correlation');
      options.plugins.zoom = getZoomOptions(true, true);
      options.scales.x.title = { display: true, text: 'Average Unit Price ($)', font: { weight: 'bold' } };
      options.scales.y.title = { display: true, text: 'Quantity Sold', font: { weight: 'bold' } };

      priceSalesChart = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [{
            label: 'Price vs Sales',
            data: scatterData,
            backgroundColor: colors.info + '99',
            borderColor: colors.info,
            borderWidth: 2,
            pointRadius: 5,
            pointHoverRadius: 10
          }]
        },
        options: options
      });
    }

    function renderRatingTrend(ratingsData){
      const ctx=document.getElementById('ratingTrendChart').getContext('2d');
      if(ratingTrendChart) ratingTrendChart.destroy();
      
      const trendData = ratingsData?.average_rating_trend || { labels: [], values: [] };

      if (!trendData.labels.length) {
        ratingTrendChart = new Chart(ctx, { 
          type: 'line', 
          data: { labels: [], datasets: [] }, 
          options: getCommonChartOptions('Rating Trend')
        });
        return;
      }

      const processed = processLargeDataset(trendData.labels, trendData.values);
      const options = getCommonChartOptions('Rating Trends Over Time');
      options.scales.y.min = 1;
      options.scales.y.max = 5;
      options.scales.y.title = { display: true, text: 'Rating (1-5)', font: { weight: 'bold' } };

      ratingTrendChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: processed.labels,
          datasets: [{
            label: 'Average Rating',
            data: processed.values,
            borderColor: colors.warning,
            backgroundColor: colors.warning + '20',
            fill: true,
            tension: 0.4,
            borderWidth: 3,
            pointRadius: processed.labels.length > 50 ? 0 : 4,
            pointHoverRadius: 8
          }]
        },
        options: options
      });
    }

    function renderRatingDistribution(ratingsData){
      const ctx=document.getElementById('ratingDistChart').getContext('2d');
      if(ratingDistChart) ratingDistChart.destroy();
      
      const distData = ratingsData?.rating_distribution || { bins: [], values: [] };

      if (!distData.bins.length) {
        ratingDistChart = new Chart(ctx, { 
          type: 'bar', 
          data: { labels: [], datasets: [] }, 
          options: getCommonChartOptions('Rating Distribution')
        });
        return;
      }

      const options = getCommonChartOptions('Rating Distribution');
      options.plugins.legend.display = false;

      ratingDistChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: distData.bins,
          datasets: [{
            label: 'Frequency',
            data: distData.values,
            backgroundColor: [
              colors.danger + 'CC', 
              colors.warning + 'CC', 
              '#eab308CC', 
              colors.success + 'CC', 
              '#059669CC'
            ],
            borderColor: [
              colors.danger, 
              colors.warning, 
              '#eab308', 
              colors.success, 
              '#059669'
            ],
            borderWidth: 2
          }]
        },
        options: options
      });
    }

    function renderRatingsVsSales(ratingsData){
      const ctx=document.getElementById('ratingsSalesChart').getContext('2d');
      if(ratingsSalesChart) ratingsSalesChart.destroy();
      
      const scatterData = ratingsData?.ratings_vs_sales_scatter || { ratings: [], quantity_sold: [] };
      const chartData = scatterData.ratings.map((rating, i) => ({
        x: rating,
        y: scatterData.quantity_sold[i] || 0
      })).filter(point => point.x > 0 && point.y >= 0);

      if (!chartData.length) {
        ratingsSalesChart = new Chart(ctx, { 
          type: 'scatter', 
          data: { datasets: [] }, 
          options: getCommonChartOptions('Ratings vs Sales')
        });
        return;
      }

      const options = getCommonChartOptions('Ratings vs Sales Performance');
      options.plugins.zoom = getZoomOptions(true, true);
      options.scales.x.title = { display: true, text: 'Average Rating (1-5)', font: { weight: 'bold' } };
      options.scales.y.title = { display: true, text: 'Quantity Sold', font: { weight: 'bold' } };
      options.scales.x.min = 1;
      options.scales.x.max = 5;

      ratingsSalesChart = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [{
            label: 'Ratings vs Sales',
            data: chartData,
            backgroundColor: colors.warning + '99',
            borderColor: colors.warning,
            borderWidth: 2,
            pointRadius: 5,
            pointHoverRadius: 10
          }]
        },
        options: options
      });
    }

    function renderSentimentChart(ratingsData){
      const ctx=document.getElementById('sentimentChart').getContext('2d');
      if(sentimentChart) sentimentChart.destroy();
      
      const sentimentData = ratingsData?.sentiment_breakdown || { labels: [], values: [] };

      if (!sentimentData.labels.length) {
        sentimentChart = new Chart(ctx, { 
          type: 'doughnut', 
          data: { labels: [], datasets: [] }, 
          options: getCommonChartOptions('Sentiment Analysis')
        });
        return;
      }

      const options = getCommonChartOptions('Customer Sentiment Analysis');
      options.plugins.legend.position = 'bottom';

      sentimentChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: sentimentData.labels,
          datasets: [{
            data: sentimentData.values,
            backgroundColor: [
              colors.success + 'CC',
              '#eab308CC',
              colors.danger + 'CC'
            ],
            borderColor: [
              colors.success,
              '#eab308',
              colors.danger
            ],
            borderWidth: 2
          }]
        },
        options: options
      });
    }

    function renderEmptyRatingCharts(){
      const emptyOptions = { 
        ...getCommonChartOptions('No Data Available'),
        plugins: {
          ...getCommonChartOptions('No Data Available').plugins,
          title: { display: true, text: 'No rating data available for selected criteria' }
        }
      };
      const emptyData = { labels: [], datasets: [] };
      
      if(ratingTrendChart) ratingTrendChart.destroy();
      if(ratingDistChart) ratingDistChart.destroy();
      if(ratingsSalesChart) ratingsSalesChart.destroy();
      if(sentimentChart) sentimentChart.destroy();
      
      ratingTrendChart = new Chart(document.getElementById('ratingTrendChart'), { type: 'line', data: emptyData, options: emptyOptions });
      ratingDistChart = new Chart(document.getElementById('ratingDistChart'), { type: 'bar', data: emptyData, options: emptyOptions });
      ratingsSalesChart = new Chart(document.getElementById('ratingsSalesChart'), { type: 'scatter', data: emptyData, options: emptyOptions });
      sentimentChart = new Chart(document.getElementById('sentimentChart'), { type: 'doughnut', data: emptyData, options: emptyOptions });
    }

  </script>
</body>
</html>
